{"ast":null,"code":"import _ from 'lodash';\nimport { v4 } from 'uuid';\nimport { findIndexesOfString, getObjectId, checkObjectId, getUserName } from '../../common-function';\nexport const chatRestrictTime = 2000;\nexport const carFreakGlobalSearch = ['carFreak', 'socialBoard', 'club', 'dealer', 'people'];\nexport const tagPrefix = '@';\nexport const hashTagPrefix = '#';\nexport const tagPrefixHashValue = '@~#}:start';\nexport const hashTagPrefixHashValue = '#^:!%start';\nexport const tagSuffixHashValue = '@^@}}end';\nexport const hashTagSuffixHashValue = '#>^}~end';\nexport const seperatorHashValue = ']<%seperator>!;_';\nexport const clubProfileViewTypes = ['admin', 'member', 'pending', 'non-member'];\nexport function parseTagStringToArray(text) {\n  if (text) {\n    let finalText = [];\n    let tagText = text.split(tagSuffixHashValue);\n    tagText = _.forEach(tagText, function (char) {\n      if (char.includes(tagPrefixHashValue)) {\n        char = char.split(tagPrefixHashValue); //split prefix , the previous 1 sure is other text\n\n        if (char[0] != null && char[0] != undefined) {\n          //Check if other text got hashtag\n          if (char[0].includes(hashTagPrefixHashValue)) {\n            let hashTagArr = parseHashTagStringToArray(char[0]);\n            finalText = finalText.concat(hashTagArr);\n          } else {\n            finalText.push({\n              type: 'normal',\n              value: char[0],\n              id: null\n            });\n          }\n        } //split prefix , the after 1 sure is tag text\n\n\n        if (char[1] != null && char[1] != undefined) {\n          char[1] = char[1].split(seperatorHashValue);\n          finalText.push({\n            type: 'tag',\n            value: char[1][0],\n            id: char[1][1]\n          });\n        }\n      } else {\n        let hashTagArr = parseHashTagStringToArray(char);\n        finalText = finalText.concat(hashTagArr);\n      }\n    });\n    return finalText;\n  } else {\n    return text;\n  }\n}\n\nfunction parseHashTagStringToArray(text) {\n  if (text) {\n    let finalText = [];\n    let tagText = text.split(hashTagSuffixHashValue);\n    tagText = _.forEach(tagText, function (char) {\n      if (char.includes(hashTagPrefixHashValue)) {\n        char = char.split(hashTagPrefixHashValue); //split prefix , the previous 1 sure is other text\n\n        if (char[0] != null && char[0] != undefined) {\n          finalText.push({\n            type: 'normal',\n            value: char[0],\n            id: null\n          });\n        } //split prefix , the after 1 sure is tag text\n\n\n        if (char[1] != null && char[1] != undefined) {\n          char[1] = char[1].split(seperatorHashValue);\n          finalText.push({\n            type: 'hashTag',\n            value: char[1][0],\n            id: char[1][1]\n          });\n        }\n      } else {\n        finalText.push({\n          type: 'normal',\n          value: char,\n          id: null\n        });\n      }\n    });\n    return finalText;\n  } else {\n    return [];\n  }\n}\n\nexport function getTagString(text, id, prefix) {\n  if (text && id) {\n    let codePrefix = prefix == '#' ? hashTagPrefixHashValue : tagPrefixHashValue;\n    let codeSuffix = prefix == '#' ? hashTagSuffixHashValue : tagSuffixHashValue;\n    return `${codePrefix}${text || ''}${seperatorHashValue}${id || ''}${codeSuffix}`;\n  } else {\n    return text;\n  }\n}\nexport function parseToTagString(text, aliasCode) {\n  if (text && _.isArray(aliasCode) && !_.isEmpty(aliasCode)) {\n    let finalText = text;\n\n    let sortedAliasCode = _.reverse(_.sortBy(aliasCode, ['position']));\n\n    _.forEach(sortedAliasCode, function (code) {\n      let name = code.name;\n      let indexes = findIndexesOfString(finalText, name);\n\n      if (_.includes(indexes, code.position)) {\n        let preText = finalText.substr(0, code.position) || '';\n        let postText = finalText.substr(code.position + name.length) || '';\n        finalText = preText + code.value + postText;\n      }\n    });\n\n    return finalText;\n  } else {\n    return text;\n  }\n}\nexport function getAliasCodeFromText(text) {\n  if (text) {\n    let aliasCode = [];\n    let structedText = '';\n    let textArr = parseTagStringToArray(text);\n    textArr = _.map(textArr, function (item) {\n      if (item.type != 'tag' && item.type != 'hashTag') {\n        return item;\n      } else {\n        item.uid = `${v4()}`;\n        return item;\n      }\n    });\n    structedText = _.compact(_.map(textArr, function (item) {\n      if (item.type != 'tag' && item.type != 'hashTag') {\n        return item.value;\n      } else {\n        return `${item.uid}${item.value}`;\n      }\n    }));\n    structedText = structedText.join('');\n\n    _.forEach(textArr, function (item) {\n      if (item.type == 'tag' || item.type == 'hashTag') {\n        let position = structedText.indexOf(item.uid);\n        structedText = structedText.replace(item.uid, '');\n        aliasCode.push({\n          position: position,\n          value: `${item.type == 'tag' ? tagPrefixHashValue : hashTagPrefixHashValue}${item.value || ''}${seperatorHashValue}${item.id || ''}${item.type == 'tag' ? tagSuffixHashValue : hashTagSuffixHashValue}`,\n          prefix: item.type == 'tag' ? tagPrefix : hashTagPrefix,\n          endPosition: position + item.value.length - 1,\n          name: item.value,\n          id: item.id,\n          createdAt: new Date().getTime()\n        });\n      }\n    });\n\n    return aliasCode;\n  } else {\n    return [];\n  }\n}\nexport function parseTagStringToPlainString(text) {\n  if (text) {\n    let textArr = parseTagStringToArray(text);\n    textArr = _.map(textArr, function (item) {\n      return item.value;\n    });\n    return textArr.join('');\n  } else {\n    return text;\n  }\n}\nexport function convertNameString(users, authUser) {\n  if (_.isArray(users) && !_.isEmpty(users)) {\n    let text = '';\n    let count = 3;\n\n    if (getObjectId(authUser)) {\n      users = _.filter(users, function (user) {\n        return checkObjectId(user, getObjectId(authUser));\n      });\n    }\n\n    _.forEach(users, function (user, index) {\n      if (index + 1 == users.length && users.length > 1) {\n        text += ` and ${getUserName(user, 'fullName')}`;\n        return false;\n      }\n\n      if (index + 1 > count) {\n        text += ` and ${users.length - count} others`;\n        return false;\n      }\n\n      if (index == 0) {\n        text += `${getUserName(user, 'fullName')}`;\n      }\n\n      if (index > 0) {\n        text += `, ${getUserName(user, 'fullName')}`;\n      }\n    });\n\n    return text;\n  } else {\n    return 'Ccar User';\n  }\n}\nexport function getViewType(join) {\n  if (_.isPlainObject(join) && !_.isEmpty(join)) {\n    if (_.get(join, ['status']) == 'approved' && _.get(join, ['role']) == 'admin') {\n      return clubProfileViewTypes[0];\n    }\n\n    if (_.get(join, ['status']) == 'approved' && _.get(join, ['role']) == 'member') {\n      return clubProfileViewTypes[1];\n    }\n\n    if (_.get(join, ['status']) == 'pending' && _.get(join, ['role']) == 'member') {\n      return clubProfileViewTypes[2];\n    }\n\n    return clubProfileViewTypes[3];\n  } else {\n    return clubProfileViewTypes[3];\n  }\n}\nexport function validateViewType(data) {\n  if (!data) {\n    return clubProfileViewTypes[3];\n  } else {\n    return _.find(clubProfileViewTypes, function (type) {\n      return type == data;\n    }) || clubProfileViewTypes[3];\n  }\n}","map":{"version":3,"sources":["/Users/faraheen/ccar-cms-next-mobile/components/carFreak/config.js"],"names":["_","v4","findIndexesOfString","getObjectId","checkObjectId","getUserName","chatRestrictTime","carFreakGlobalSearch","tagPrefix","hashTagPrefix","tagPrefixHashValue","hashTagPrefixHashValue","tagSuffixHashValue","hashTagSuffixHashValue","seperatorHashValue","clubProfileViewTypes","parseTagStringToArray","text","finalText","tagText","split","forEach","char","includes","undefined","hashTagArr","parseHashTagStringToArray","concat","push","type","value","id","getTagString","prefix","codePrefix","codeSuffix","parseToTagString","aliasCode","isArray","isEmpty","sortedAliasCode","reverse","sortBy","code","name","indexes","position","preText","substr","postText","length","getAliasCodeFromText","structedText","textArr","map","item","uid","compact","join","indexOf","replace","endPosition","createdAt","Date","getTime","parseTagStringToPlainString","convertNameString","users","authUser","count","filter","user","index","getViewType","isPlainObject","get","validateViewType","data","find"],"mappings":"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","sourcesContent":["\nimport _ from 'lodash';\nimport { v4 } from 'uuid';\nimport { findIndexesOfString, getObjectId, checkObjectId, getUserName } from '../../common-function';\n\nexport const chatRestrictTime = 2000;\nexport const carFreakGlobalSearch = ['carFreak', 'socialBoard', 'club', 'dealer', 'people'];\nexport const tagPrefix = '@';\nexport const hashTagPrefix = '#';\nexport const tagPrefixHashValue = '@~#}:start';\nexport const hashTagPrefixHashValue = '#^:!%start';\nexport const tagSuffixHashValue = '@^@}}end';\nexport const hashTagSuffixHashValue = '#>^}~end';\nexport const seperatorHashValue = ']<%seperator>!;_';\nexport const clubProfileViewTypes = ['admin', 'member', 'pending', 'non-member'];\n\n\nexport function parseTagStringToArray(text) {\n    if (text) {\n        let finalText = [];\n        let tagText = text.split(tagSuffixHashValue);\n        tagText = _.forEach(tagText, function (char) {\n\n            if (char.includes(tagPrefixHashValue)) {\n                char = char.split(tagPrefixHashValue);\n                //split prefix , the previous 1 sure is other text\n                if (char[0] != null && char[0] != undefined) {\n\n                    //Check if other text got hashtag\n                    if (char[0].includes(hashTagPrefixHashValue)) {\n                        let hashTagArr = parseHashTagStringToArray(char[0]);\n                        finalText = finalText.concat(hashTagArr);\n                    } else {\n                        finalText.push(\n                            {\n                                type: 'normal',\n                                value: char[0],\n                                id: null,\n                            }\n                        );\n                    }\n                }\n\n                //split prefix , the after 1 sure is tag text\n                if (char[1] != null && char[1] != undefined) {\n                    char[1] = char[1].split(seperatorHashValue);\n                    finalText.push(\n                        {\n                            type: 'tag',\n                            value: char[1][0],\n                            id: char[1][1],\n                        }\n                    );\n                }\n            } else {\n                let hashTagArr = parseHashTagStringToArray(char);\n                finalText = finalText.concat(hashTagArr);\n            }\n\n        })\n\n        return finalText;\n    } else {\n        return text;\n    }\n}\n\nfunction parseHashTagStringToArray(text) {\n    if (text) {\n        let finalText = [];\n        let tagText = text.split(hashTagSuffixHashValue);\n        tagText = _.forEach(tagText, function (char) {\n\n            if (char.includes(hashTagPrefixHashValue)) {\n                char = char.split(hashTagPrefixHashValue);\n                //split prefix , the previous 1 sure is other text\n                if (char[0] != null && char[0] != undefined) {\n                    finalText.push(\n                        {\n                            type: 'normal',\n                            value: char[0],\n                            id: null,\n                        }\n                    );\n                }\n\n                //split prefix , the after 1 sure is tag text\n                if (char[1] != null && char[1] != undefined) {\n                    char[1] = char[1].split(seperatorHashValue);\n                    finalText.push(\n                        {\n                            type: 'hashTag',\n                            value: char[1][0],\n                            id: char[1][1],\n                        }\n                    );\n                }\n            } else {\n\n                finalText.push(\n                    {\n                        type: 'normal',\n                        value: char,\n                        id: null,\n                    }\n                );\n            }\n\n        })\n\n        return finalText;\n    } else {\n        return [];\n    }\n}\n\nexport function getTagString(text, id, prefix) {\n    if (text && id) {\n        let codePrefix = prefix == '#' ? hashTagPrefixHashValue : tagPrefixHashValue;\n        let codeSuffix = prefix == '#' ? hashTagSuffixHashValue : tagSuffixHashValue;\n        return `${codePrefix}${text || ''}${seperatorHashValue}${id || ''}${codeSuffix}`;\n    } else {\n        return text;\n    }\n}\n\nexport function parseToTagString(text, aliasCode) {\n\n    if (text && _.isArray(aliasCode) && !_.isEmpty(aliasCode)) {\n        let finalText = text;\n        let sortedAliasCode = _.reverse(_.sortBy(aliasCode, ['position']))\n        _.forEach(sortedAliasCode, function (code) {\n            let name = code.name;\n            let indexes = findIndexesOfString(finalText, name);\n\n            if (_.includes(indexes, code.position)) {\n                let preText = finalText.substr(0, code.position) || '';\n                let postText = finalText.substr(code.position + name.length) || '';\n                finalText = preText + code.value + postText;\n            }\n\n        })\n        return finalText;\n    } else {\n        return text;\n    }\n}\n\nexport function getAliasCodeFromText(text) {\n\n    if (text) {\n\n        let aliasCode = [];\n        let structedText = '';\n        let textArr = parseTagStringToArray(text);\n        textArr = _.map(textArr, function (item) {\n            if (item.type != 'tag' && item.type != 'hashTag') {\n                return item;\n            } else {\n                item.uid = `${v4()}`;\n                return item;\n            }\n        });\n\n        structedText = _.compact(_.map(textArr, function (item) {\n            if (item.type != 'tag' && item.type != 'hashTag') {\n                return item.value;\n            } else {\n                return `${item.uid}${item.value}`;\n            }\n        }));\n\n        structedText = structedText.join('');\n\n\n        _.forEach(textArr, function (item) {\n            if (item.type == 'tag' || item.type == 'hashTag') {\n                let position = structedText.indexOf(item.uid);\n                structedText = structedText.replace(item.uid, '');\n                aliasCode.push({\n                    position: position,\n                    value: `${item.type == 'tag' ? tagPrefixHashValue : hashTagPrefixHashValue}${item.value || ''}${seperatorHashValue}${item.id || ''}${item.type == 'tag' ? tagSuffixHashValue : hashTagSuffixHashValue}`,\n                    prefix: item.type == 'tag' ? tagPrefix : hashTagPrefix,\n                    endPosition: position + item.value.length - 1,\n                    name: item.value,\n                    id: item.id,\n                    createdAt: new Date().getTime(),\n                });\n            }\n        })\n\n        return aliasCode;\n\n    } else {\n        return [];\n    }\n}\n\nexport function parseTagStringToPlainString(text) {\n\n    if (text) {\n        let textArr = parseTagStringToArray(text);\n        textArr = _.map(textArr, function (item) {\n            return item.value;\n        })\n\n        return textArr.join('');\n    } else {\n        return text;\n    }\n}\n\n\nexport function convertNameString(users, authUser) {\n    if (_.isArray(users) && !_.isEmpty(users)) {\n\n        let text = '';\n        let count = 3;\n        if (getObjectId(authUser)) {\n            users = _.filter(users, function (user) {\n                return checkObjectId(user, getObjectId(authUser));\n            })\n        }\n\n        _.forEach(users, function (user, index) {\n            if (index + 1 == users.length && users.length > 1) {\n                text += ` and ${getUserName(user, 'fullName')}`\n                return false;\n            }\n\n            if (index + 1 > count) {\n                text += ` and ${users.length - count} others`\n                return false;\n            }\n\n            if (index == 0) {\n                text += `${getUserName(user, 'fullName')}`\n            }\n\n            if (index > 0) {\n                text += `, ${getUserName(user, 'fullName')}`\n            }\n        })\n\n        return text;\n    } else {\n        return 'Ccar User';\n    }\n}\n\n\nexport function getViewType(join) {\n\n    if (_.isPlainObject(join) && !_.isEmpty(join)) {\n        if (_.get(join, ['status']) == 'approved' && _.get(join, ['role']) == 'admin') {\n            return clubProfileViewTypes[0];\n        }\n\n        if (_.get(join, ['status']) == 'approved' && _.get(join, ['role']) == 'member') {\n            return clubProfileViewTypes[1];\n        }\n\n        if (_.get(join, ['status']) == 'pending' && _.get(join, ['role']) == 'member') {\n            return clubProfileViewTypes[2];\n        }\n\n        return clubProfileViewTypes[3];\n    } else {\n        return clubProfileViewTypes[3];\n    }\n}\n\n\nexport function validateViewType(data) {\n\n    if (!data) {\n        return clubProfileViewTypes[3];\n    } else {\n        return _.find(clubProfileViewTypes, function (type) {\n            return type == data;\n        }) || clubProfileViewTypes[3];\n    }\n}"]},"metadata":{},"sourceType":"module"}